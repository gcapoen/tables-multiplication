<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tables de multiplication</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; background:#0b1020; color:#eaf0ff; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    .card { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding: 16px; }
    h1 { font-size: 22px; margin: 0 0 10px; }
    h2 { font-size: 18px; margin: 0 0 10px; opacity:.95; }
    label { display:block; margin: 10px 0 6px; opacity:.95; }
    select, input[type="number"], input[type="text"] {
      width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25); color:#eaf0ff; outline:none;
    }
    .row { display:flex; gap: 12px; flex-wrap: wrap; }
    .row > div { flex: 1; min-width: 220px; }
    button {
      padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,.2);
      background: rgba(255,255,255,.12); color:#eaf0ff; cursor:pointer; font-weight:600;
    }
    button.primary { background: #3b82f6; border-color: #3b82f6; }
    button.danger { background: rgba(239,68,68,.25); border-color: rgba(239,68,68,.45); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .hud { display:flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
    .pill { padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); }
    .question { font-size: 42px; font-weight: 800; letter-spacing: .5px; margin: 10px 0; }
    .choices { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .ok { color:#22c55e; font-weight:700; }
    .ko { color:#ef4444; font-weight:700; }
    .small { opacity:.85; font-size: 13px; line-height: 1.35; }
    .hidden { display:none; }
    .divider { height:1px; background: rgba(255,255,255,.12); margin: 12px 0; }
    .modeBox { display:flex; gap:10px; flex-wrap:wrap; }
    .modeBox button { flex:1; min-width: 240px; }

    table { width:100%; border-collapse: collapse; margin-top: 10px; overflow: hidden; border-radius: 12px; }
    th, td { padding: 10px 10px; border-bottom: 1px solid rgba(255,255,255,.10); text-align: left; }
    th { background: rgba(255,255,255,.08); }
    tr:hover td { background: rgba(255,255,255,.04); }
    .tag { display:inline-block; padding: 4px 8px; border: 1px solid rgba(255,255,255,.18); border-radius: 999px; font-size: 12px; opacity:.9; }

    details { background: rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.10); border-radius: 12px; padding: 10px 12px; }
    details + details { margin-top: 10px; }
    summary { cursor: pointer; font-weight: 650; }
    .right { float:right; opacity:.9; font-weight:600; }
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    .muted { opacity:.8; }
  </style>
</head>
<body>
<div class="wrap">

  <!-- ACCUEIL -->
  <div id="screen-setup" class="card">
    <h1>R√©viser les multiplications</h1>
    <div class="small">
      Tables 1‚Üí10 (option 1‚Üí20). Multiplicateurs ‚â§ 12. Difficult√© progressive optionnelle.<br>
      <b>Classique</b> : 10s pour choisir mode + 10s pour r√©pondre. <b>Challenge</b> : 5 minutes sans timer par question.
    </div>

    <div class="row" style="margin-top:12px;">
      <div>
        <label>Mode de jeu</label>
        <select id="gameMode">
          <option value="classic">Classique (s√©rie)</option>
          <option value="challenge">Challenge 5 minutes</option>
        </select>
      </div>
      <div id="qcBox">
        <label>Nombre de questions (Classique)</label>
        <input id="questionCount" type="number" min="5" max="200" value="20" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Tables (valeur max)</label>
        <select id="maxTable">
          <option value="10">De 1 √† 10</option>
          <option value="20">De 1 √† 20</option>
        </select>
      </div>
      <div>
        <label>Difficult√© progressive</label>
        <select id="adaptive">
          <option value="on">Oui (s‚Äôadapte)</option>
          <option value="off">Non (toujours jusqu‚Äô√† 12)</option>
        </select>
      </div>
    </div>

    <div class="divider"></div>

    <div class="small">
      <b>Bar√®me Classique</b> : +15 (√©crit), +10 (QCM), -5 (faux/temps). Bonus : +5 toutes les 5 bonnes r√©ponses d‚Äôaffil√©e.<br>
      <b>Bar√®me Challenge</b> : +10 (bonne), -5 (fausse), 0 (passer). Bonus : +5 toutes les 5 bonnes r√©ponses d‚Äôaffil√©e.
    </div>

    <div class="btnRow" style="margin-top: 14px;">
      <button class="primary" id="startBtn">D√©marrer</button>
      <button id="historyBtn">Historique</button>
      <button id="resetBestBtn">R√©initialiser meilleur score</button>
    </div>

    <div id="bestLine" class="small" style="margin-top:10px;"></div>
  </div>

  <!-- JEU -->
  <div id="screen-game" class="card hidden">
    <div class="hud">
      <div class="pill">Question: <span id="qIndex">1</span>/<span id="qTotal">20</span></div>
      <div class="pill">‚è±Ô∏è <span id="timeLeft">10</span></div>
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">S√©rie: <span id="streak">0</span></div>
      <div class="pill">Bonus s√©ries: <span id="bonusCount">0</span></div>
      <div class="pill">Difficult√©: <span id="diffTag">1/3</span></div>
    </div>

    <div id="phaseTitle" class="small">Choisis ton mode</div>
    <div class="question" id="questionText">8 √ó 7 = ?</div>

    <!-- PHASE CHOIX MODE (Classique uniquement) -->
    <div id="chooseModeBox" class="modeBox">
      <button class="primary" id="chooseInputBtn">‚úçÔ∏è R√©ponse √©crite (+15)</button>
      <button id="chooseMcqBtn">üß© QCM 4 choix (+10)</button>
    </div>

    <!-- PHASE REPONSE -->
    <div id="mcqBox" class="choices hidden"></div>

    <div id="inputBox" class="hidden">
      <label>Ta r√©ponse</label>
      <input id="answerInput" type="text" inputmode="numeric" placeholder="Tape le r√©sultat" />
      <div class="btnRow">
        <button class="primary" id="validateBtn">Valider</button>
        <button class="danger" id="skipBtn">Passer</button>
      </div>
    </div>

    <div id="feedback" style="margin-top:12px; min-height: 22px;"></div>
    <div class="btnRow">
      <button id="nextBtn" class="primary" disabled>Suivant</button>
      <button id="stopBtn" class="danger">Arr√™ter</button>
      <button id="quitBtn">Quitter</button>
    </div>
  </div>

  <!-- FIN -->
  <div id="screen-end" class="card hidden">
    <h2>R√©sultat</h2>
    <div id="summary" style="margin: 10px 0;"></div>

    <div class="divider"></div>
    <h2>Stats par table</h2>
    <div class="small">Regarde surtout les tables avec un faible % et beaucoup de ‚ÄúPasser‚Äù.</div>
    <div id="statsTable"></div>

    <div class="btnRow" style="margin-top: 14px;">
      <button class="primary" id="replayBtn">Rejouer</button>
      <button id="endHistoryBtn">Voir historique</button>
      <button id="backBtn">Retour r√©glages</button>
    </div>
  </div>

  <!-- HISTORIQUE -->
  <div id="screen-history" class="card hidden">
    <h2>Historique</h2>
    <div class="small muted">Les sessions sont enregistr√©es sur cet appareil (localStorage).</div>

    <div class="btnRow" style="margin-top: 10px;">
      <button class="primary" id="historyBackBtn">Retour</button>
      <button class="danger" id="clearHistoryBtn">Effacer tout l‚Äôhistorique</button>
    </div>

    <div class="divider"></div>
    <div id="historyList"></div>
  </div>

</div>

<script>
(() => {
  // --------- Elements
  const setup = document.getElementById('screen-setup');
  const game  = document.getElementById('screen-game');
  const end   = document.getElementById('screen-end');
  const historyScreen = document.getElementById('screen-history');

  const gameModeEl = document.getElementById('gameMode');
  const qcBox = document.getElementById('qcBox');
  const questionCountEl = document.getElementById('questionCount');
  const maxTableEl = document.getElementById('maxTable');
  const adaptiveEl = document.getElementById('adaptive');

  const startBtn = document.getElementById('startBtn');
  const historyBtn = document.getElementById('historyBtn');
  const resetBestBtn = document.getElementById('resetBestBtn');

  const qIndexEl = document.getElementById('qIndex');
  const qTotalEl = document.getElementById('qTotal');
  const timeLeftEl = document.getElementById('timeLeft');
  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const bonusCountEl = document.getElementById('bonusCount');
  const diffTagEl = document.getElementById('diffTag');

  const phaseTitle = document.getElementById('phaseTitle');
  const questionText = document.getElementById('questionText');

  const chooseModeBox = document.getElementById('chooseModeBox');
  const chooseInputBtn = document.getElementById('chooseInputBtn');
  const chooseMcqBtn = document.getElementById('chooseMcqBtn');

  const mcqBox = document.getElementById('mcqBox');
  const inputBox = document.getElementById('inputBox');
  const answerInput = document.getElementById('answerInput');
  const validateBtn = document.getElementById('validateBtn');
  const skipBtn = document.getElementById('skipBtn');

  const feedback = document.getElementById('feedback');
  const nextBtn = document.getElementById('nextBtn');
  const stopBtn = document.getElementById('stopBtn');
  const quitBtn = document.getElementById('quitBtn');

  const summary = document.getElementById('summary');
  const statsTable = document.getElementById('statsTable');
  const replayBtn = document.getElementById('replayBtn');
  const endHistoryBtn = document.getElementById('endHistoryBtn');
  const backBtn = document.getElementById('backBtn');

  const bestLine = document.getElementById('bestLine');

  const historyBackBtn = document.getElementById('historyBackBtn');
  const clearHistoryBtn = document.getElementById('clearHistoryBtn');
  const historyList = document.getElementById('historyList');

  // --------- Constants
  const MAX_MULTIPLIER_OPERAND = 12;

  // Classic timers
  const CHOOSE_SECONDS = 10;
  const ANSWER_SECONDS = 10;

  // Challenge duration
  const CHALLENGE_SECONDS = 5 * 60;

  // Scoring
  const SCORE_CLASSIC_INPUT_OK = 15;
  const SCORE_CLASSIC_MCQ_OK   = 10;
  const SCORE_CHALLENGE_OK     = 10;
  const SCORE_BAD              = -5;
  const SCORE_SKIP             = 0;
  const BONUS_EVERY_N_STREAK   = 5;   // every 5 correct in a row
  const BONUS_POINTS           = 5;

  // Storage keys
  const BEST_KEY    = 'mul_best_score_v4';
  const HISTORY_KEY = 'mul_session_history_v2';

  // --------- State
  let cfg = {};
  let timer = null;

  let phase = 'choose';       // classic only: 'choose'|'answer'|'reveal'
  let current = null;         // {a,b,answer,choices[]}
  let selectedMode = null;    // 'input'|'mcq' (classic), 'challenge' uses input only

  let qIndex = 0;
  let score = 0;
  let streak = 0;
  let bonusCount = 0;
  let correctCount = 0;
  let bestStreak = 0;
  let askedCount = 0;

  // difficulty
  let diffTier = 1;           // 1..3
  let recentResults = [];     // last answers true/false (skip does not count)

  // stats per table
  // tableStats[a] = { asked, correct, wrong, skipped, timeSumMs, answered }
  let tableStats = {};
  let answerPhaseStartTs = null;

  // session time
  let sessionStartTs = null;
  let challengeEndsAtTs = null;

  // anti-repeat
  let historyPairs = [];

  // --------- UI helpers
  function showOnly(screen) {
    setup.classList.add('hidden');
    game.classList.add('hidden');
    end.classList.add('hidden');
    historyScreen.classList.add('hidden');
    screen.classList.remove('hidden');
  }

  function showBest() {
    const best = Number(localStorage.getItem(BEST_KEY) || 0);
    bestLine.textContent = `Meilleur score enregistr√© sur cet appareil : ${best}`;
  }

  function clampInt(v, min, max, fallback) {
    const n = parseInt(v, 10);
    if (Number.isNaN(n)) return fallback;
    return Math.max(min, Math.min(max, n));
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clearTimer() {
    if (timer) clearInterval(timer);
    timer = null;
  }

  function setTimeLabelClassic(sec) {
    timeLeftEl.textContent = `${sec}s`;
  }

  function setTimeLabelChallenge(remSec) {
    const m = Math.floor(remSec / 60);
    const s = remSec % 60;
    timeLeftEl.textContent = `${m}:${String(s).padStart(2,'0')}`;
  }

  function startCountdownClassic(seconds, onTimeout) {
    clearTimer();
    let t = seconds;
    setTimeLabelClassic(t);
    timer = setInterval(() => {
      t--;
      setTimeLabelClassic(t);
      if (t <= 0) { clearTimer(); onTimeout(); }
    }, 1000);
  }

  function startChallengeTimer() {
    clearTimer();
    challengeEndsAtTs = Date.now() + CHALLENGE_SECONDS*1000;
    setTimeLabelChallenge(CHALLENGE_SECONDS);
    timer = setInterval(() => {
      const rem = Math.max(0, Math.ceil((challengeEndsAtTs - Date.now()) / 1000));
      setTimeLabelChallenge(rem);
      if (rem <= 0) {
        clearTimer();
        finish(true, false); // ended by timer
      }
    }, 250);
  }

  function updateHUD() {
    scoreEl.textContent = score;
    streakEl.textContent = streak;
    bonusCountEl.textContent = bonusCount;
    diffTagEl.textContent = `${diffTier}/3`;
  }

  function maybeApplyStreakBonus() {
    if (streak > 0 && streak % BONUS_EVERY_N_STREAK === 0) {
      score += BONUS_POINTS;
      bonusCount++;
      feedback.innerHTML += ` <span class="ok">+${BONUS_POINTS} bonus (s√©rie de ${BONUS_EVERY_N_STREAK})</span>`;
    }
  }

  function sameAsRecent(a, b) {
    const key = `${a}x${b}`;
    return historyPairs.includes(key);
  }

  function pushHistoryPair(a, b) {
    const key = `${a}x${b}`;
    historyPairs.push(key);
    if (historyPairs.length > 14) historyPairs.shift();
  }

  function ensureTableStats(maxTable) {
    tableStats = {};
    for (let t = 1; t <= maxTable; t++) {
      tableStats[t] = { asked: 0, correct: 0, wrong: 0, skipped: 0, timeSumMs: 0, answered: 0 };
    }
  }

  function recordStats(tableA, kind, responseMs) {
    // kind: 'correct'|'wrong'|'skipped'
    const s = tableStats[tableA];
    if (!s) return;
    s.asked++;
    if (kind === 'correct') s.correct++;
    if (kind === 'wrong') s.wrong++;
    if (kind === 'skipped') s.skipped++;
    if (kind !== 'skipped' && Number.isFinite(responseMs) && responseMs >= 0) {
      s.timeSumMs += responseMs;
      s.answered++;
    }
  }

  // --------- Progressive difficulty
  function tierMaxB() {
    if (!cfg.adaptive) return MAX_MULTIPLIER_OPERAND;
    if (diffTier === 1) return 6;
    if (diffTier === 2) return 9;
    return 12;
  }

  function updateDifficultyTier() {
    if (!cfg.adaptive) { diffTier = 3; return; }
    const w = recentResults.slice(-10);
    if (w.length < 6) return;
    const acc = w.filter(Boolean).length / w.length;
    if (acc >= 0.85 && diffTier < 3) diffTier++;
    if (acc <= 0.55 && diffTier > 1) diffTier--;
  }

  // Weighted pick: focus weaker tables + skipped
  function pickTableA() {
    const maxT = cfg.maxTable;
    const weights = [];
    let sum = 0;

    for (let t = 1; t <= maxT; t++) {
      const s = tableStats[t];
      const asked = s.asked;
      const acc = asked > 0 ? (s.correct / asked) : 0.5;

      let w = 1;
      if (asked < 3) w += 1.2;                 // explore
      w += (1 - acc) * 1.7;                    // focus weaknesses
      w += Math.min(0.9, (s.wrong * 0.08) + (s.skipped * 0.10)); // extra focus for wrong+skip

      weights.push(w);
      sum += w;
    }

    let r = Math.random() * sum;
    for (let i = 0; i < weights.length; i++) {
      r -= weights[i];
      if (r <= 0) return i + 1;
    }
    return randInt(1, maxT);
  }

  function pickB() {
    const maxB = tierMaxB();
    if (maxB <= 1) return 1;
    if (!cfg.adaptive || diffTier === 1) return randInt(1, maxB);
    const u = Math.random();
    const biased = Math.ceil(Math.pow(u, 0.65) * maxB); // bias toward higher values
    return Math.max(1, Math.min(maxB, biased));
  }

  // --------- QCM choices
  function buildChoices(answer, a, b) {
    const set = new Set([answer]);
    const candidates = [
      answer + 1, answer - 1, answer + 2, answer - 2,
      answer + 10, answer - 10,
      a * (b + 1), a * (b - 1),
      (a + 1) * b, (a - 1) * b
    ].filter(x => Number.isFinite(x) && x >= 0);

    while (set.size < 4) {
      if (candidates.length) {
        const x = candidates.splice(randInt(0, candidates.length - 1), 1)[0];
        set.add(x);
      } else {
        set.add(answer + randInt(-15, 15));
      }
    }

    const arr = Array.from(set);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function generateQuestion() {
    let tries = 0;
    let a, b;
    do {
      a = pickTableA();
      b = pickB();
      tries++;
    } while (sameAsRecent(a, b) && tries < 10);

    pushHistoryPair(a, b);
    const answer = a * b;
    current = { a, b, answer, choices: buildChoices(answer, a, b) };
    questionText.textContent = `${a} √ó ${b} = ?`;
  }

  // --------- Classic flow
  function setPhaseChooseClassic() {
    phase = 'choose';
    selectedMode = null;
    feedback.textContent = '';
    nextBtn.disabled = true;

    phaseTitle.textContent = `Choisis ton mode (10s)`;
    chooseModeBox.classList.remove('hidden');
    mcqBox.classList.add('hidden');
    inputBox.classList.add('hidden');

    startCountdownClassic(CHOOSE_SECONDS, () => setModeAndAskClassic('mcq'));
  }

  function setModeAndAskClassic(mode) {
    if (!current || phase !== 'choose') return;
    selectedMode = mode; // 'input'|'mcq'
    clearTimer();
    setPhaseAnswerClassic();
  }

  function setPhaseAnswerClassic() {
    phase = 'answer';
    feedback.textContent = '';
    nextBtn.disabled = true;
    phaseTitle.textContent = `R√©ponds (10s)`;

    chooseModeBox.classList.add('hidden');
    answerPhaseStartTs = Date.now();

    if (selectedMode === 'mcq') {
      mcqBox.classList.remove('hidden');
      inputBox.classList.add('hidden');
      mcqBox.innerHTML = '';
      current.choices.forEach(val => {
        const btn = document.createElement('button');
        btn.textContent = val;
        btn.onclick = () => submitClassic(val, false, false);
        mcqBox.appendChild(btn);
      });
    } else {
      mcqBox.classList.add('hidden');
      inputBox.classList.remove('hidden');
      answerInput.value = '';
      answerInput.focus();
    }

    startCountdownClassic(ANSWER_SECONDS, () => submitClassic(null, true, false));
  }

  function disableAnswerUI() {
    Array.from(mcqBox.querySelectorAll('button')).forEach(b => b.disabled = true);
    validateBtn.disabled = true;
    skipBtn.disabled = true;
    answerInput.disabled = true;
    chooseInputBtn.disabled = true;
    chooseMcqBtn.disabled = true;
  }

  function enableAnswerUI() {
    validateBtn.disabled = false;
    skipBtn.disabled = false;
    answerInput.disabled = false;
  }

  function submitClassic(value, timedOut=false, isSkip=false) {
    if (!current) return;
    if (cfg.gameMode !== 'classic' || phase !== 'answer') return;

    clearTimer();
    disableAnswerUI();

    const responseMs = answerPhaseStartTs ? (Date.now() - answerPhaseStartTs) : NaN;

    askedCount++;
    const correct = (!isSkip && value === current.answer);

    if (isSkip) {
      // classic: passer = 0 (mais on compte comme "skipped" dans stats)
      recordStats(current.a, 'skipped', NaN);
      feedback.innerHTML = `<span class="muted">‚è≠Ô∏è Pass√© (0 pt)</span>`;
      // pas de changement de streak
    } else if (correct) {
      const gained = (selectedMode === 'input') ? SCORE_CLASSIC_INPUT_OK : SCORE_CLASSIC_MCQ_OK;
      score += gained;
      streak++;
      bestStreak = Math.max(bestStreak, streak);
      correctCount++;

      recordStats(current.a, 'correct', responseMs);
      recentResults.push(true);
      updateDifficultyTier();

      feedback.innerHTML = `<span class="ok">‚úÖ Bravo !</span> +${gained} pts`;
      maybeApplyStreakBonus();
    } else {
      score = Math.max(0, score + SCORE_BAD);
      streak = 0;

      recordStats(current.a, 'wrong', responseMs);
      recentResults.push(false);
      updateDifficultyTier();

      const reason = timedOut ? "Temps √©coul√©" : "Mauvaise r√©ponse";
      feedback.innerHTML = `<span class="ko">‚ùå ${reason}.</span> Bonne r√©ponse : <b>${current.answer}</b> (${SCORE_BAD} pts)`;
    }

    updateHUD();
    phase = 'reveal';
    nextBtn.disabled = false;
  }

  function nextClassic() {
    qIndex++;
    qIndexEl.textContent = qIndex;

    if (qIndex > cfg.totalQuestions) {
      finish(false, true);
      return;
    }

    enableAnswerUI();
    generateQuestion();
    setPhaseChooseClassic();
  }

  // --------- Challenge flow (5 min, no per question timer)
  function showChallengeQuestion() {
    phaseTitle.textContent = `Challenge : r√©ponds vite (pas de timer par question)`;
    chooseModeBox.classList.add('hidden');
    mcqBox.classList.add('hidden');

    inputBox.classList.remove('hidden');
    selectedMode = 'input';
    answerInput.value = '';
    answerInput.focus();

    // In challenge, "Suivant" inutile
    nextBtn.disabled = true;
    nextBtn.classList.add('hidden');

    // stop label
    stopBtn.textContent = "Arr√™ter le challenge";
    stopBtn.classList.remove('hidden');

    // skip enabled
    enableAnswerUI();
    feedback.textContent = '';
    answerPhaseStartTs = Date.now();
  }

  function submitChallenge(value, isSkip=false) {
    if (!current) return;
    if (cfg.gameMode !== 'challenge') return;

    const responseMs = answerPhaseStartTs ? (Date.now() - answerPhaseStartTs) : NaN;

    askedCount++;
    qIndex++;
    qIndexEl.textContent = qIndex;

    if (isSkip) {
      // skip = 0
      recordStats(current.a, 'skipped', NaN);
      feedback.innerHTML = `<span class="muted">‚è≠Ô∏è Pass√© (0 pt)</span>`;
      // streak unchanged (tu peux aussi d√©cider de reset, mais tu n‚Äôas pas demand√©)
    } else if (value === current.answer) {
      score += SCORE_CHALLENGE_OK;
      streak++;
      bestStreak = Math.max(bestStreak, streak);
      correctCount++;

      recordStats(current.a, 'correct', responseMs);
      recentResults.push(true);
      updateDifficultyTier();

      feedback.innerHTML = `<span class="ok">‚úÖ +${SCORE_CHALLENGE_OK} pts</span>`;
      maybeApplyStreakBonus();
    } else {
      score = Math.max(0, score + SCORE_BAD);
      streak = 0;

      recordStats(current.a, 'wrong', responseMs);
      recentResults.push(false);
      updateDifficultyTier();

      feedback.innerHTML = `<span class="ko">‚ùå ${SCORE_BAD} pts</span> (bonne r√©ponse: <b>${current.answer}</b>)`;
    }

    updateHUD();

    // next question immediately (unless time is over)
    if (challengeEndsAtTs && Date.now() >= challengeEndsAtTs) {
      finish(true, false);
      return;
    }
    generateQuestion();
    showChallengeQuestion();
  }

  // --------- Finish + stats + history
  function computeTotals(statsObj) {
    let asked=0, correct=0, wrong=0, skipped=0, answered=0, timeSumMs=0;
    for (const k in statsObj) {
      const s = statsObj[k];
      asked += s.asked || 0;
      correct += s.correct || 0;
      wrong += s.wrong || 0;
      skipped += s.skipped || 0;
      answered += s.answered || 0;
      timeSumMs += s.timeSumMs || 0;
    }
    const accAnswered = (correct + wrong) ? Math.round((correct / (correct + wrong)) * 100) : 0;
    const accAll = asked ? Math.round((correct / asked) * 100) : 0;
    const avgSec = answered ? (timeSumMs / answered / 1000) : 0;
    return { asked, correct, wrong, skipped, accAnswered, accAll, avgSec };
  }

  function renderStatsTable(containerEl, statsObj, maxTable) {
    const rows = [];
    for (let t = 1; t <= maxTable; t++) {
      const s = statsObj[t] || { asked:0, correct:0, wrong:0, skipped:0, timeSumMs:0, answered:0 };
      const asked = s.asked;
      const answered = s.correct + s.wrong;
      const acc = answered > 0 ? Math.round((s.correct / answered) * 100) : 0; // accuracy excluding skips
      const skipRate = asked > 0 ? Math.round((s.skipped / asked) * 100) : 0;
      const avgSec = s.answered > 0 ? (s.timeSumMs / s.answered / 1000) : 0;
      rows.push({ t, asked, correct:s.correct, wrong:s.wrong, skipped:s.skipped, acc, skipRate, avgSec, answeredCount: s.answered });
    }

    // Weak tables: low accuracy OR lots of skips
    const weak = rows
      .filter(r => r.asked > 0)
      .sort((a,b) => (a.acc - b.acc) || (b.skipRate - a.skipRate) || (b.asked - a.asked))
      .slice(0,3);

    const tip = weak.length
      ? `<div class="small" style="margin:10px 0;">
           <span class="tag">√Ä travailler</span>
           ${weak.map(r => `table de ${r.t} (r√©ussite ${r.acc}%, pass√©s ${r.skipped})`).join(', ')}
         </div>`
      : `<div class="small" style="margin:10px 0;"><span class="tag">Info</span> Aucune question enregistr√©e.</div>`;

    containerEl.innerHTML = `
      ${tip}
      <table>
        <thead>
          <tr>
            <th>Table</th><th>Questions</th><th>‚úÖ</th><th>‚ùå</th><th>‚è≠Ô∏è</th><th>% r√©ussite*</th><th>Temps moyen</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => `
            <tr>
              <td>${r.t}</td>
              <td>${r.asked}</td>
              <td>${r.correct}</td>
              <td>${r.wrong}</td>
              <td>${r.skipped}</td>
              <td>${(r.correct + r.wrong) ? (r.acc + '%') : '-'}</td>
              <td>${r.answeredCount ? (r.avgSec.toFixed(1) + 's') : '-'}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
      <div class="small muted" style="margin-top:8px;">* % r√©ussite calcul√© sur les r√©ponses donn√©es (sans compter ‚ÄúPasser‚Äù).</div>
    `;
  }

  function snapshotTableStats(maxTable) {
    const snap = {};
    for (let t = 1; t <= maxTable; t++) {
      const s = tableStats[t];
      snap[t] = { asked: s.asked, correct: s.correct, wrong: s.wrong, skipped: s.skipped, timeSumMs: s.timeSumMs, answered: s.answered };
    }
    return snap;
  }

  function addSessionToHistory(session) {
    const arr = loadHistory();
    arr.unshift(session);
    if (arr.length > 60) arr.length = 60;
    saveHistory(arr);
  }

  function finish(stoppedByUser, saveBestIfClassic) {
    clearTimer();

    const endedAt = Date.now();
    const durationSec = sessionStartTs ? Math.round((endedAt - sessionStartTs)/1000) : 0;

    const totals = computeTotals(tableStats);

    const modeLabel =
      (cfg.gameMode === 'challenge') ? (stoppedByUser ? "Challenge (arr√™t manuel)" : "Challenge (5 min)")
      : "Classique";

    summary.innerHTML = `
      <div class="pill">Mode : <b>${modeLabel}</b></div><br/>
      <div class="pill">Score final : <b>${score}</b></div><br/>
      <div class="pill">Questions : <b>${totals.asked}</b> ‚Ä¢ ‚úÖ ${totals.correct} ‚Ä¢ ‚ùå ${totals.wrong} ‚Ä¢ ‚è≠Ô∏è ${totals.skipped}</div><br/>
      <div class="pill">% r√©ussite (r√©ponses donn√©es) : <b>${totals.accAnswered}%</b></div><br/>
      <div class="pill">Meilleure s√©rie : <b>${bestStreak}</b> ‚Ä¢ Bonus s√©ries : <b>${bonusCount}</b></div><br/>
      <div class="small">Tables 1‚Üí${cfg.maxTable} ‚Ä¢ Difficult√© progressive : ${cfg.adaptive ? 'Oui' : 'Non'}</div>
    `;

    // Best score (only classic by default)
    const best = Number(localStorage.getItem(BEST_KEY) || 0);
    if (saveBestIfClassic && score > best) localStorage.setItem(BEST_KEY, String(score));
    showBest();

    // Save in history
    const session = {
      id: endedAt,
      endedAt,
      durationSec,
      gameMode: cfg.gameMode,
      totalQuestions: cfg.totalQuestions,
      stoppedByUser: !!stoppedByUser,
      maxTable: cfg.maxTable,
      adaptive: cfg.adaptive,
      score,
      bestStreak,
      bonusCount,
      correctCount,
      askedCount: totals.asked,
      tableStats: snapshotTableStats(cfg.maxTable)
    };
    addSessionToHistory(session);

    renderStatsTable(statsTable, tableStats, cfg.maxTable);
    showOnly(end);
  }

  // --------- History
  function loadHistory() {
    try {
      const raw = localStorage.getItem(HISTORY_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function saveHistory(arr) {
    localStorage.setItem(HISTORY_KEY, JSON.stringify(arr));
  }

  function formatDate(ts) {
    const d = new Date(ts);
    const pad = n => String(n).padStart(2, '0');
    return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  function deleteSession(id) {
    const arr = loadHistory().filter(s => s.id !== id);
    saveHistory(arr);
    renderHistory();
  }

  function renderHistory() {
    const arr = loadHistory();
    if (!arr.length) {
      historyList.innerHTML = `<div class="small">Aucune session enregistr√©e pour l‚Äôinstant.</div>`;
      return;
    }

    historyList.innerHTML = arr.map(s => {
      const totals = computeTotals(s.tableStats || {});
      const modeLabel = (s.gameMode === 'challenge')
        ? (s.stoppedByUser ? 'Challenge (arr√™t)' : 'Challenge (5 min)')
        : `Classique (${s.totalQuestions || '-'} q)`;

      const durationMin = s.durationSec ? Math.max(0, Math.round(s.durationSec/60)) : 0;
      const durationStr = s.durationSec ? `${durationMin} min` : '-';

      const tableDivId = `hist_table_${s.id}`;

      return `
        <details>
          <summary>
            ${formatDate(s.endedAt)} ‚Äî <b>${modeLabel}</b>
            <span class="right">Score ${s.score} ‚Ä¢ ${totals.accAnswered}%</span>
          </summary>
          <div class="small" style="margin-top:8px;">
            Tables 1‚Üí${s.maxTable} ‚Ä¢ Progressif: ${s.adaptive ? 'Oui' : 'Non'} ‚Ä¢ Dur√©e: ${durationStr}<br>
            Questions: ${totals.asked} ‚Ä¢ ‚úÖ ${totals.correct} ‚Ä¢ ‚ùå ${totals.wrong} ‚Ä¢ ‚è≠Ô∏è ${totals.skipped}<br>
            Meilleure s√©rie: ${s.bestStreak || 0} ‚Ä¢ Bonus s√©ries: ${s.bonusCount || 0}
          </div>

          <div id="${tableDivId}"></div>

          <div class="btnRow">
            <button class="danger" data-del="${s.id}">Supprimer cette session</button>
          </div>
        </details>
      `;
    }).join('');

    const arr2 = loadHistory();
    for (const s of arr2) {
      const div = document.getElementById(`hist_table_${s.id}`);
      if (div) renderStatsTable(div, s.tableStats || {}, s.maxTable || 10);
    }

    Array.from(historyList.querySelectorAll('button[data-del]')).forEach(btn => {
      btn.onclick = () => deleteSession(Number(btn.getAttribute('data-del')));
    });
  }

  // --------- Start game
  function startGame() {
    cfg = {
      gameMode: gameModeEl.value,                           // 'classic' | 'challenge'
      totalQuestions: clampInt(questionCountEl.value, 5, 200, 20),
      maxTable: Number(maxTableEl.value),                   // 10 | 20
      adaptive: (adaptiveEl.value === 'on')
    };

    // reset
    qIndex = (cfg.gameMode === 'challenge') ? 0 : 1;
    score = 0;
    streak = 0;
    bonusCount = 0;
    correctCount = 0;
    askedCount = 0;
    bestStreak = 0;

    diffTier = cfg.adaptive ? 1 : 3;
    recentResults = [];
    historyPairs = [];

    ensureTableStats(cfg.maxTable);

    qIndexEl.textContent = qIndex;
    qTotalEl.textContent = (cfg.gameMode === 'classic') ? cfg.totalQuestions : '‚àû';
    updateHUD();

    // UI per mode
    nextBtn.classList.remove('hidden');
    nextBtn.disabled = true;

    stopBtn.classList.remove('hidden');
    stopBtn.textContent = (cfg.gameMode === 'challenge') ? 'Arr√™ter le challenge' : 'Arr√™ter';
    stopBtn.onclick = () => {
      const saveBest = (cfg.gameMode === 'classic');
      finish(true, saveBest);
    };

    sessionStartTs = Date.now();

    showOnly(game);
    generateQuestion();

    if (cfg.gameMode === 'classic') {
      phaseTitle.textContent = '';
      // show time as seconds for classic
      setTimeLabelClassic(CHOOSE_SECONDS);
      // next button used
      nextBtn.classList.remove('hidden');
      // stop button should exist but doesn't end automatically
      // skip in classic becomes "Passer" = 0
      skipBtn.textContent = "Passer";
      setPhaseChooseClassic();
    } else {
      // challenge
      startChallengeTimer();
      skipBtn.textContent = "Passer";
      showChallengeQuestion();
    }
  }

  function goSetup() {
    clearTimer();
    showOnly(setup);
  }

  function goHistory() {
    renderHistory();
    showOnly(historyScreen);
  }

  // --------- Events
  startBtn.onclick = startGame;

  chooseInputBtn.onclick = () => setModeAndAskClassic('input');
  chooseMcqBtn.onclick = () => setModeAndAskClassic('mcq');

  validateBtn.onclick = () => {
    const v = answerInput.value.trim();
    const n = Number(v);
    if (v === '' || Number.isNaN(n)) {
      feedback.innerHTML = `<span class="ko">Entre un nombre üôÇ</span>`;
      return;
    }
    if (cfg.gameMode === 'classic') {
      submitClassic(n, false, false);
    } else {
      submitChallenge(n, false);
    }
  };

  answerInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') validateBtn.click();
  });

  skipBtn.onclick = () => {
    if (cfg.gameMode === 'classic') {
      submitClassic(null, false, true);
    } else {
      submitChallenge(null, true);
    }
  };

  nextBtn.onclick = () => {
    if (cfg.gameMode === 'classic') nextClassic();
  };

  quitBtn.onclick = goSetup;

  replayBtn.onclick = startGame;
  backBtn.onclick = goSetup;
  endHistoryBtn.onclick = goHistory;

  historyBtn.onclick = goHistory;
  historyBackBtn.onclick = goSetup;

  clearHistoryBtn.onclick = () => {
    if (confirm("Effacer tout l‚Äôhistorique ?")) {
      localStorage.removeItem(HISTORY_KEY);
      renderHistory();
    }
  };

  resetBestBtn.onclick = () => {
    localStorage.removeItem(BEST_KEY);
    showBest();
  };

  gameModeEl.addEventListener('change', () => {
    qcBox.classList.toggle('hidden', gameModeEl.value === 'challenge');
  });

  // Init
  qcBox.classList.toggle('hidden', gameModeEl.value === 'challenge');
  showBest();
})();
</script>
</body>
</html>
